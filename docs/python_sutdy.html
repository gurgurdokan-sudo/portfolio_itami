<!DOCTYPE html>
<html lang="ja">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>portfolio</title>
	<link rel="stylesheet" href="CSS/style.css">
	<script src="JS/main.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
	<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />

<body>
	<div class="background-svg">
		<svg width="100%" height="100%" viewBox="0 0 400 400" preserveAspectRatio="none">
			<defs>
				<pattern id="syntaxPattern" x="0" y="0" width="200" height="100" patternUnits="userSpaceOnUse">
					<text x="0" y="10">ITAMITAMITAMI</text>
				</pattern>
			</defs>
			<rect class="stripe-background" x="0" y="0" width="100%" height="100%" fill="url(#syntaxPattern)" />
		</svg>
	</div>
	<header>
		<h1>伊丹 裕哉[ITAMI YUYA]</h1>
		<p>このサイトは職業訓練校で学んだ事をポートフォリオにしたWEBサイトです<br />
			【自己紹介<a href="index.html">Topページ</a>】</p>
		<nav>
			<li data-href="java_sutdy.html" onclick="Tohref(this)">Java</li>
			<li data-href="this" onclick="Tohref(this)">Python</li>
			<li data-href="javaServlet_sutdy.html" onclick="Tohref(this)">Javaサーブレット</li>
			<li data-href="untiy_sutdy.html" onclick="Tohref(this)">Untiy</li>
		</nav>
	</header>
	<ul>
		<li>Webスクレイピング</li>
		<div class="while">
			　このコードでは、ユーザーが入力した食材をもとに「オレンジページ」からレシピを検索し、
			一覧表示します。このコードでは、WEBスプレイピングで取得したデータを表示するのみですが、
			BeautifulSoupを使用する事により取得してきたデータ(html)を綺麗に成形し
			必要なデータを別の所で使いやすくする<span class="js-marker">の外部ライブラリの活用を理解しました。</span>
		</div>
		<input type="checkbox" id="popup-on1">
		<b>■実行結果</b>
		<label for="popup-on1" class="btn-open">食材:ニンジンを入力した結果を開く</label>
		<div class="popup">
			<label for="popup-on1" class="icon-close">×</label>
			<div class="popup-content">
				実行画像<br>
				<img src="img/" alt="実行画像" class="layer-img">
			</div>
		</div>
		<div class="mycode">Python<pre class="short"><code class="language-python">
import requests
from bs4 import BeautifulSoup
search_meal= input('食材を入力＞＞')
search='https://www.orangepage.net/recipes/search?q='+search_meal
r = requests.get(search) #ページ情報の取得
# print(r.headers) #header情報の表示
print("----------------------------")
html = BeautifulSoup(r.content, 'html.parser')
tit=html.find_all("p",class_="font-medium leading-[1.5] text-title mb-2 line-clamp-2 max-md:line-clamp-3 max-md:text-xs")# text のみを抽出
tit_string =[tit.string for tit in tit]
for t in tit_string:
    if search_meal in t:
        print(t)
			</code>
		</pre>
		</div>
		<li>従来型の機械学習モデル</li>
		<div class="while">
			　データをCSVで取り込んだ後に欠損データの様々な補完方法や、サーキットラーンで学習した
			Modelを表示させる事で<span class="js-marker">根本的なif文の集合体として動いていることを実感し、アルゴリズムの構造理解が深まりました。</span>
		</div>
		<input type="checkbox" id="popup-on1">
		<b>■実行結果</b>
		<label for="popup-on2" class="btn-open">作成したModelを表示した結果を開く</label>
		<div class="popup">
			<label for="popup-on2" class="icon-close">×</label>
			<div class="popup-content">
				実行画像<br>
				<img src="img/" alt="実行画像" class="layer-img">
			</div>
		</div>
		<div class="mycode">Python<pre><code class="language-python">
from sklearn import tree
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.tree import plot_tree

# データ読み込み
df = pd.read_csv('iris.csv')
# 欠損値処理
df['花弁長さ'] = df['花弁長さ'].fillna(0)
coloms = df.mean(numeric_only=True)
df2 = df.fillna(coloms)
xcol = ['がく片長さ', 'がく片幅', '花弁長さ', '花弁幅']
x = df2[xcol]
t = df2['種類']
x_train, x_test, t_train, t_test = train_test_split(x, t, test_size=0.2, random_state=0)
model = tree.DecisionTreeClassifier(max_depth=12, random_state=0)
model.fit(x_train, t_train)
# テストデータで予測
t_pred = model.predict(x_test)
print("Accuracy:", accuracy_score(t_test, t_pred))
print("Classification Report:\n", classification_report(t_test, t_pred))

# 決定木の可視化
plt.figure(figsize=(12, 8))
plot_tree(model, feature_names=xcol, class_names=model.classes_, filled=True)
plt.show()
			</code>
		</pre>
		</div>
		<div class="while">
			　同じデータを用いて、SVM（サポートベクターマシン）による分類も試しました。<br />
			技術者として内部構造を理解していないと使えないから、完全に理解しなくてもSVMでより高度な分類を
			丸投げしても使えるという新体験でした。<br />
			「モデルに丸投げしても動く」ことは、<span class="js-marker">実務における機械学習の強みの一つだと感じました。</span><br />
		</div>
		<div class="mycode">Python
			<pre class="short"><code class="language-python">
model = LinearSVC() # 線形SVMモデルを定義
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
				</code></pre>
		</div></div>
		<li>戦争カードゲームとPythonの強力ライブラリ</li>
		<b>■問題</b><br />
		<div class="gray ms-1">
		・デッキとして1-13の番号が書かれたカードをあなたとCPUが13枚ずつそれぞれ持つ<br />
		・それぞれのデッキをシャッフルし裏向きに置く<br />
		・お互いに一番上のカードをオープン、数字の大きいほう(1が最小13が最大)がそのラウンドを勝利し、
		  &#8221;２枚のカード&#8221;を獲得できる。<br />
		・もし同じ数字がでた場合は、勝敗が決まるまで次のカードを出し合って、勝ったほうが引き分けのラウンドを含めた枚数分のカードを獲得できる。<br />
		・お互いの手札がなくなったらゲーム終了で、獲得したカードの枚数が多いほうが最終的な勝者となる。<br />
		</div>
		<div class="while">
			　演習課題のカードゲームを作成しました。リスト内包表記や簡単なCUIゲームでも感じる
			<span class="js-marker">Pythonのシンプルさで複雑な分岐も整理して書ける</span>ため、アルゴリズムの理解を深めるのに最適な題材でした。
		</div>
		<input type="checkbox" id="popup-on1">
		<b>■実行結果</b>
		<label for="popup-on1" class="btn-open">実行結果を開く</label>
		<div class="popup">
			<label for="popup-on1" class="icon-close">×</label>
			<div class="popup-content">実行画像<br><img src="img/" alt="実行画像" class="layer-img">
			</div>
		</div>
		<div class="mycode">Python<pre><code class="language-python">
import random
user_card_list = [i for i in range(1,14)]
cpu_card_list = [i for i in range(1,14)]
'''test date
user_card_list = [1,2,3,4,5,1,1,1,1,1,1,2,3]
cpu_card_list = [1,2,3,4,5,1,1,1,1,1,1,2,3]'''
random.shuffle(user_card_list)
random.shuffle(cpu_card_list)
print(user_card_list)
print(cpu_card_list)
'''-------------中で使う変数を宣言------------'''
win=lose=draw=card=0 #scores
bo_continue=False
count_card = 2

i=0
while i<13:
    if bo_continue:
        count_card += 2
        bo_continue=False #戻す
    print(f'{i+1 : >3}番目の勝負 ||',end='')
    if user_card_list[i] == cpu_card_list[i]:
        print(f' YOU：{user_card_list[i]:>2} || CPU：{cpu_card_list[i]:>2}')
        draw+=1
        i+=1
        bo_continue=True #切り替えて取得枚数を増やす
        print("引き分け")
        continue

    elif user_card_list[i] > cpu_card_list[i]:
        win+=1
        card += count_card
        print(f' YOU：{user_card_list[i]:>2} || CPU：{cpu_card_list[i]:>2}')
        print(f"userの勝ち{count_card}枚を取得")
        count_card = 2
    elif user_card_list[i] < cpu_card_list[i]:
        print(f' YOU：{user_card_list[i]:>2} || CPU：{cpu_card_list[i]:>2}')
        lose+=1
        print("cpuの勝ち")
        count_card = 2
    i+=1

print("Game finsh")
print(f'勝利回数：{win}||負け回数：{lose}||引き分け回数：{draw}')
print(f'取得カード枚数：{card}||',end='')
if card > 13:
    str_result = f'win||CPUのCard枚数：{card-26}||'
elif card < 13:
    str_result = f'lose||CPUのCard枚数：{26-card}||'
else:
    str_result = f'draw||CPUのCard枚数：{26-card}||'
print(str_result)
			</code></pre></div>
	<div class="while">
		　さらに、ライブラリを使用してより短く簡潔にする事にもチャレンジしました。<br />
		保守や今後の運用を考えた時には、長くてもわかりやすいコードを書くように心掛けてきましたが、
		<span class="js-marker">あえてコードを短くする事でよりPythonのメリット</span>を感じました。
	</div>
<div class="mycode">Python<pre class="short"><code class="language-python"></code>
import random
user, pc = [random.sample(range(1, 14), 13) for _ in range(2)]
you_win = pc_win = stock = 0
for i, (u, p) in enumerate(zip(user, pc), 1):
    stock += 2
    if u == p:
        result = '引き分け、キャリーオーバー!'
    elif u > p:
        you_win += stock
        result = f'あなたの勝ち!{stock}枚ゲット!'
        stock = 0
    else:
        pc_win += stock
        result = f'PCの勝ち({stock})'
        stock = 0
    print(f'{i}回戦 あなた:{u}, PC:{p}, {result}')
print(f'獲得枚数 {you_win}対{pc_win}で{"あなた" if you_win > pc_win else "PC"}の勝ち!')
</code></pre></div>
	</ul>

	<footer>
		<p>&copy; 2025 yuya All rights reserved. </p>
		<a href="index.html">topに戻る</a>
	</footer>
</body>

</html>